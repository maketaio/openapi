package goserver

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/maketaio/openapi/codegen/model"
	"github.com/maketaio/openapi/util/set"
	"github.com/pb33f/libopenapi"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

type Config struct {
	In  string
	Out string
	Pkg string
}

func Generate(cfg *Config) error {
	bytes, err := os.ReadFile(cfg.In)
	if err != nil {
		return err
	}

	doc, err := libopenapi.NewDocument(bytes)
	if err != nil {
		return err
	}

	dm, err := doc.BuildV3Model()
	if err != nil {
		return err
	}

	r := model.NewRegistry()
	if err := r.Collect(dm); err != nil {
		return fmt.Errorf("failed to collect declarations: %w", err)
	}

	imports := analyzeImports(r)

	namer := newDeclNamer()
	namer.generate(r)

	src, err := emit(r, imports, namer, cfg)
	if err != nil {
		return fmt.Errorf("failed to generate code: %w", err)
	}

	formatted, err := format.Source(src)
	if err != nil {
		return fmt.Errorf("failed to format code: %w", err)
	}

	outDir := filepath.Dir(cfg.Out)

	if err := os.MkdirAll(outDir, 0o755); err != nil {
		return err
	}

	if err := os.WriteFile(cfg.Out, formatted, 0o644); err != nil {
		return err
	}

	fmt.Printf("Successfully generated %s\n", cfg.Out)
	return nil
}

func emit(r *model.Registry, imports set.Set[string], namer *declNamer, cfg *Config) ([]byte, error) {
	var buf bytes.Buffer

	fmt.Fprintf(&buf, "// Code generated by oapigen; DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "package %s\n\n", packageName(cfg))
	if imports.Len() > 0 {
		fmt.Fprintf(&buf, "import (\n")
		for module := range imports {
			fmt.Fprintf(&buf, "%q\n", module)
		}
		fmt.Fprintf(&buf, ")\n\n")
	}

	r.Range(func(id string, decl *model.Declaration) bool {
		fmt.Fprintf(&buf, "// %s is the generated type for schema %s\n", namer.nameFor(id), decl.Loc)

		writeDecl(&buf, namer, decl)
		writeEnum(&buf, namer, decl)
		writeMarshalUnmarshal(&buf, namer, decl)
		writeValidation(&buf, namer, decl)

		return true
	})

	return buf.Bytes(), nil
}

func writeDoc(buf *bytes.Buffer, doc []string) {
	for _, doc := range doc {
		buf.WriteString("// ")
		buf.WriteString(doc)
		buf.WriteString("\n")
	}
}

func writeDecl(buf *bytes.Buffer, namer *declNamer, decl *model.Declaration) {
	writeDoc(buf, decl.Doc)
	if decl.Deprecated {
		buf.WriteString("// Deprecated ")
		buf.WriteString("\n")
	}
	buf.WriteString("type ")
	buf.WriteString(namer.nameFor(decl.ID))
	buf.WriteString(" ")
	writeType(buf, namer, decl.Type)
	buf.WriteString("\n")
}

func writeType(buf *bytes.Buffer, namer *declNamer, typ *model.Type) {
	switch typ.Kind {
	case model.TypeInt32:
		buf.WriteString("int32")
	case model.TypeInt64:
		buf.WriteString("int64")
	case model.TypeFloat64:
		buf.WriteString("float64")
	case model.TypeString:
		buf.WriteString("string")
	case model.TypeBool:
		buf.WriteString("bool")
	case model.TypeBinary:
		buf.WriteString("[]byte")
	case model.TypeTime:
		buf.WriteString("time.Time")
	case model.TypeRef:
		buf.WriteString(namer.nameFor(typ.Ref))
	case model.TypeArray:
		buf.WriteString("[]")
		writeType(buf, namer, typ.Elem)
	case model.TypeMap:
		buf.WriteString("map[string]")
		writeType(buf, namer, typ.Elem)
	case model.TypeObject:
		buf.WriteString("struct {\n")
		for _, field := range typ.Fields {
			writeDoc(buf, field.Doc)

			if field.Deprecated {
				buf.WriteString("// Deprecated ")
				buf.WriteString("\n")
			}

			buf.WriteString(toTitle(field.Name))
			buf.WriteString(" ")
			if !field.Required {
				buf.WriteString("*")
			}
			writeType(buf, namer, field.Type)
			buf.WriteString(" `json:\"")
			buf.WriteString(field.Name)
			if !field.Required {
				buf.WriteString(",omitzero")
			}
			buf.WriteString("\"`\n")
		}

		if typ.Elem != nil {
			buf.WriteString("AdditionalProperties map[string]")
			writeType(buf, namer, typ.Elem)
			buf.WriteString(" `json:\"-\"`\n")
		}

		buf.WriteString("}")
	case model.TypeUnknown:
		buf.WriteString("json.RawMessage")
	}
}

func writeEnum(buf *bytes.Buffer, namer *declNamer, decl *model.Declaration) {
	if len(decl.Type.Enum) == 0 {
		return
	}

	buf.WriteString("const (")
	for _, enum := range decl.Type.Enum {
		writeDoc(buf, enum.Doc)

		suffix := enum.Name
		if suffix == "" {
			if enum.Int32 != nil {
				suffix = strconv.FormatInt(int64(*enum.Int32), 10)
			} else if enum.Int64 != nil {
				suffix = strconv.FormatInt(*enum.Int64, 10)
			} else if enum.Float64 != nil {
				formatted := strconv.FormatFloat(*enum.Float64, 'g', -1, 64)
				formatted = strings.ReplaceAll(formatted, ".", "_")
				formatted = strings.ReplaceAll(formatted, "-", "m")
				suffix = formatted
			} else if enum.Str != nil {
				suffix = *enum.Str
			} else if enum.Bool != nil {
				suffix = strconv.FormatBool(*enum.Bool)
			}
		}

		lit := ""
		if enum.Int32 != nil {
			lit = strconv.FormatInt(int64(*enum.Int32), 10)
		} else if enum.Int64 != nil {
			lit = strconv.FormatInt(*enum.Int64, 10)
		} else if enum.Float64 != nil {
			lit = strconv.FormatFloat(*enum.Float64, 'g', -1, 64)
		} else if enum.Str != nil {
			lit = strconv.Quote(*enum.Str)
		} else if enum.Bool != nil {
			lit = strconv.FormatBool(*enum.Bool)
		}

		declName := namer.nameFor(decl.ID)
		fmt.Fprintf(buf, "%s %s = %s\n", declName+toTitle(suffix), declName, lit)
	}
	buf.WriteString(")\n")
}

func writeMarshalUnmarshal(buf *bytes.Buffer, namer *declNamer, decl *model.Declaration) {
	if decl.Type.Kind == model.TypeObject && decl.Type.Elem != nil {
		declName := namer.nameFor(decl.ID)

		fmt.Fprintf(buf, "func (o *%s) UnmarshalJSON(data []byte) error {\n", declName)
		fmt.Fprintf(buf, "type alias %s\n", declName)
		buf.WriteString("a := alias{}\n")
		buf.WriteString("if err := json.Unmarshal(data, &a); err != nil {\n")
		buf.WriteString("return err\n")
		buf.WriteString("}\n")
		fmt.Fprintf(buf, "*o = %s(a)\n", declName)
		buf.WriteString("ap := map[string]")
		writeType(buf, namer, decl.Type.Elem)
		buf.WriteString("{}\n")
		buf.WriteString("if err := json.Unmarshal(data, &ap); err != nil {\n")
		buf.WriteString("return err\n")
		buf.WriteString("}\n")
		for _, field := range decl.Type.Fields {
			fmt.Fprintf(buf, "delete(ap, %q)\n", field.Name)
		}
		buf.WriteString("if len(ap) > 0 {\n")
		buf.WriteString("o.AdditionalProperties = ap\n")
		buf.WriteString("}\n")
		buf.WriteString("return nil\n")
		buf.WriteString("}\n\n")

		fmt.Fprintf(buf, "func (o %s) MarshalJSON() ([]byte, error) {\n", declName)
		fmt.Fprintf(buf, "o := make(map[string]any, len(o.AdditionalProperties)+%d)\n", len(decl.Type.Fields))
		for _, field := range decl.Type.Fields {
			fmt.Fprintf(buf, "o[%q] = o.%s\n", field.Name, field.Name)
		}
		buf.WriteString("for k, v := range o.AdditionalProperties {\n")
		buf.WriteString("o[k] = v\n")
		buf.WriteString("}\n")
		buf.WriteString("return json.Marshal(o)\n")
		buf.WriteString("}\n\n")

		return
	}
}

func writeValidation(buf *bytes.Buffer, namer *declNamer, decl *model.Declaration) {
	if !requiresValidation(decl.Type) {
		return
	}

	declName := namer.nameFor(decl.ID)
	fmt.Fprintf(buf, "func (o *%s) Validate(path validation.Path) []*validation.Error {\n", declName)
	buf.WriteString("if o == nil { return nil }\n")
	buf.WriteString("var errors []*validation.Error\n")
	writeValidationBody(buf, decl.Type)
	buf.WriteString("return errors\n")
	buf.WriteString("}\n\n")
}

func writeValidationBody(buf *bytes.Buffer, typ *model.Type) {
	if typ.Kind == model.TypeInt32 || typ.Kind == model.TypeInt64 {
		if typ.Max != nil {
			if typ.ExclMax {
				fmt.Fprintf(buf, "if *o >= %d {\n", *typ.Max)
				buf.WriteString("errors = append(errors, &validation.Error{\n")
				buf.WriteString("Path: path,\n")
				buf.WriteString("Detail: validation.Detail{\n")
				buf.WriteString("Code: validation.CodeIntLT,\n")
				fmt.Fprintf(buf, "IntLT: ptr.To(int64(%d)),\n", *typ.Max)
				buf.WriteString("},\n")
				fmt.Fprintf(buf, "Message: fmt.Sprintf(\"%%s must be less than %d\", path),\n", *typ.Max)
				buf.WriteString("})\n")
				buf.WriteString("}\n")
			} else {
				fmt.Fprintf(buf, "if *o > %d {\n", *typ.Max)
				buf.WriteString("errors = append(errors, &validation.Error{\n")
				buf.WriteString("Path: path,\n")
				buf.WriteString("Detail: validation.Detail{\n")
				buf.WriteString("Code: validation.CodeIntLTE,\n")
				fmt.Fprintf(buf, "IntLTE: ptr.To(int64(%d)),\n", *typ.Max)
				buf.WriteString("},\n")
				fmt.Fprintf(buf, "Message: fmt.Sprintf(\"%%s must be less than or equal to %d\", path),\n", *typ.Max)
				buf.WriteString("})\n")
				buf.WriteString("}\n")
			}
		}

		if typ.Min != nil {
			if typ.ExclMin {
				fmt.Fprintf(buf, "if *o <= %d {\n", *typ.Min)
				buf.WriteString("errors = append(errors, &validation.Error{\n")
				buf.WriteString("Path: path,\n")
				buf.WriteString("Detail: validation.Detail{\n")
				buf.WriteString("Code: validation.CodeIntGT,\n")
				fmt.Fprintf(buf, "IntGT: ptr.To(int64(%d)),\n", *typ.Min)
				buf.WriteString("},\n")
				fmt.Fprintf(buf, "Message: fmt.Sprintf(\"%%s must be greater than %d\", path),\n", *typ.Min)
				buf.WriteString("})\n")
				buf.WriteString("}\n")
			} else {
				fmt.Fprintf(buf, "if *o < %d {\n", *typ.Min)
				buf.WriteString("errors = append(errors, &validation.Error{\n")
				buf.WriteString("Path: path,\n")
				buf.WriteString("Detail: validation.Detail{\n")
				buf.WriteString("Code: validation.CodeIntGTE,\n")
				fmt.Fprintf(buf, "IntGTE: ptr.To(int64(%d)),\n", *typ.Min)
				buf.WriteString("},\n")
				fmt.Fprintf(buf, "Message: fmt.Sprintf(\"%%s must be greater than or equal to %d\", path),\n", *typ.Min)
				buf.WriteString("})\n")
				buf.WriteString("}\n")
			}
		}

		if typ.MultipleOf != nil {
			fmt.Fprintf(buf, "if *o %% %d != 0 {\n", *typ.MultipleOf)
			buf.WriteString("errors = append(errors, &validation.Error{\n")
			buf.WriteString("Path: path,\n")
			buf.WriteString("Detail: validation.Detail{\n")
			buf.WriteString("Code: validation.CodeIntMultipleOf,\n")
			fmt.Fprintf(buf, "IntMultipleOf: ptr.To(int64(%d)),\n", *typ.MultipleOf)
			buf.WriteString("},\n")
			fmt.Fprintf(buf, "Message: fmt.Sprintf(\"%%s must be a multiple of %d\", path),\n", *typ.MultipleOf)
			buf.WriteString("})\n")
			buf.WriteString("}\n")
		}
	}

	if typ.Kind == model.TypeFloat64 {
		if typ.MaxF != nil {
			if typ.ExclMax {
				fmt.Fprintf(buf, "if *o >= %g {\n", *typ.MaxF)
				buf.WriteString("errors = append(errors, &validation.Error{\n")
				buf.WriteString("Path: path,\n")
				buf.WriteString("Detail: validation.Detail{\n")
				buf.WriteString("Code: validation.CodeNumLT,\n")
				fmt.Fprintf(buf, "NumLT: ptr.To(%g),\n", *typ.MaxF)
				buf.WriteString("},\n")
				fmt.Fprintf(buf, "Message: fmt.Sprintf(\"%%s must be less than %g\", path),\n", *typ.MaxF)
				buf.WriteString("})\n")
				buf.WriteString("}\n")
			} else {
				fmt.Fprintf(buf, "if *o > %g {\n", *typ.MaxF)
				buf.WriteString("errors = append(errors, &validation.Error{\n")
				buf.WriteString("Path: path,\n")
				buf.WriteString("Detail: validation.Detail{\n")
				buf.WriteString("Code: validation.CodeNumLTE,\n")
				fmt.Fprintf(buf, "NumLTE: ptr.To(%g),\n", *typ.MaxF)
				buf.WriteString("},\n")
				fmt.Fprintf(buf, "Message: fmt.Sprintf(\"%%s must be less than or equal to %g\", path),\n", *typ.MaxF)
				buf.WriteString("})\n")
				buf.WriteString("}\n")
			}
		}

		if typ.MinF != nil {
			if typ.ExclMin {
				fmt.Fprintf(buf, "if *o <= %g {\n", *typ.MinF)
				buf.WriteString("errors = append(errors, &validation.Error{\n")
				buf.WriteString("Path: path,\n")
				buf.WriteString("Detail: validation.Detail{\n")
				buf.WriteString("Code: validation.CodeNumGT,\n")
				fmt.Fprintf(buf, "NumGT: ptr.To(%g),\n", *typ.MinF)
				buf.WriteString("},\n")
				fmt.Fprintf(buf, "Message: fmt.Sprintf(\"%%s must be greater than %g\", path),\n", *typ.MinF)
				buf.WriteString("})\n")
				buf.WriteString("}\n")
			} else {
				fmt.Fprintf(buf, "if *o < %g {\n", *typ.MinF)
				buf.WriteString("errors = append(errors, &validation.Error{\n")
				buf.WriteString("Path: path,\n")
				buf.WriteString("Detail: validation.Detail{\n")
				buf.WriteString("Code: validation.CodeNumGTE,\n")
				fmt.Fprintf(buf, "NumGTE: ptr.To(%g),\n", *typ.MinF)
				buf.WriteString("},\n")
				fmt.Fprintf(buf, "Message: fmt.Sprintf(\"%%s must be greater than or equal to %g\", path),\n", *typ.MinF)
				buf.WriteString("})\n")
				buf.WriteString("}\n")
			}
		}
	}
}

func packageName(cfg *Config) string {
	if cfg.Pkg != "" {
		return cfg.Pkg
	}

	return filepath.Base(filepath.Dir(cfg.Out))
}

func toTitle(s string) string {
	if s == "" {
		return ""
	}

	return cases.Title(language.English, cases.NoLower).String(s)
}

func analyzeImports(r *model.Registry) set.Set[string] {
	imports := set.NewSet[string]()

	r.Range(func(id string, m *model.Declaration) bool {
		imports.Merge(doAnalyzeImports(m.Type))
		return true
	})

	return imports
}

func doAnalyzeImports(typ *model.Type) set.Set[string] {
	imports := set.NewSet[string]()

	if requiresValidation(typ) {
		imports.Add("github.com/maketaio/openapi/runtime/validation")
		imports.Add("github.com/maketaio/openapi/util/ptr")
		imports.Add("fmt")
	}

	if typ.Kind == model.TypeTime {
		imports.Add("time")
		return imports
	}

	if typ.Kind == model.TypeUnknown {
		imports.Add("encoding/json")
		return imports
	}

	if typ.Kind == model.TypeArray || typ.Kind == model.TypeMap {
		return doAnalyzeImports(typ.Elem)
	}

	if typ.Kind == model.TypeObject {
		for _, field := range typ.Fields {
			imports.Merge(doAnalyzeImports(field.Type))
		}

		if typ.Elem != nil {
			imports.Merge(doAnalyzeImports(typ.Elem))
		}
	}

	return imports
}

func requiresValidation(typ *model.Type) bool {
	if typ.Kind == model.TypeInt32 || typ.Kind == model.TypeInt64 {
		return typ.Max != nil || typ.Min != nil || typ.MultipleOf != nil
	}

	if typ.Kind == model.TypeFloat64 {
		return typ.MaxF != nil || typ.MinF != nil
	}

	if typ.Kind == model.TypeMap || typ.Kind == model.TypeArray {
		return typ.Len != nil || typ.Max != nil || typ.Min != nil || requiresValidation(typ.Elem)
	}

	if typ.Kind == model.TypeObject {
		if typ.Len != nil || typ.Max != nil || typ.Min != nil {
			return true
		}

		for _, field := range typ.Fields {
			if requiresValidation(field.Type) {
				return true
			}
		}

		if typ.Elem != nil {
			return requiresValidation(typ.Elem)
		}

		return false
	}

	return false
}

type declNamer struct {
	names   map[string]string
	counter map[string]int
}

func newDeclNamer() *declNamer {
	return &declNamer{
		names:   map[string]string{},
		counter: map[string]int{},
	}
}

func (n *declNamer) generate(r *model.Registry) {
	// Generate names for top level declarations first
	r.Range(func(id string, decl *model.Declaration) bool {
		if !decl.Loc.IsTopLevel() {
			return false
		}

		n.names[decl.ID] = toTitle(decl.Loc.Root)
		n.counter[n.names[decl.ID]] = 0

		return true
	})

	// Generate names for nested declarations
	r.Range(func(id string, decl *model.Declaration) bool {
		if decl.Loc.IsTopLevel() {
			return false
		}

		baseName := toTitle(decl.Loc.Root)
		for _, seg := range decl.Loc.Path {
			switch seg.Kind {
			case model.SegmentProperty:
				baseName += toTitle(seg.Name)
			case model.SegmentAdditionalProperties:
				baseName += "AdditionalProperty"
			case model.SegmentItems:
				baseName += "Item"
			}
		}

		name := baseName
		for {
			count, found := n.counter[baseName]
			if !found {
				break
			}

			count++
			n.counter[baseName] = count
			name = baseName + strconv.Itoa(count)
		}

		n.names[decl.ID] = name

		return true
	})
}

func (n *declNamer) nameFor(id string) string {
	return n.names[id]
}
