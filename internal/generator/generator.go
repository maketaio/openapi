package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"

	"github.com/maketaio/api/internal/util/set"
	"github.com/pb33f/libopenapi"
	v3 "github.com/pb33f/libopenapi/datamodel/high/v3"
)

type Config struct {
	In  string
	Out string
	Pkg string
}

func Generate(cfg *Config) error {
	bytes, err := os.ReadFile(cfg.In)
	if err != nil {
		return err
	}

	doc, err := libopenapi.NewDocument(bytes)
	if err != nil {
		return err
	}

	dm, err := doc.BuildV3Model()
	if err != nil {
		return err
	}

	decls, err := collectDecls(dm)
	if err != nil {
		return fmt.Errorf("failed to collect top level declarations: %w", err)
	}

	importSet := analyzeImports(decls)

	src, err := doGenerate(decls, importSet, cfg)
	if err != nil {
		return fmt.Errorf("failed to generate code: %w", err)
	}

	formatted, err := format.Source(src)
	if err != nil {
		return fmt.Errorf("failed to format code: %w", err)
	}

	outDir := filepath.Dir(cfg.Out)

	if err := os.MkdirAll(outDir, 0o755); err != nil {
		return err
	}

	if err := os.WriteFile(cfg.Out, formatted, 0o644); err != nil {
		return err
	}

	fmt.Printf("Successfully generated %s\n", cfg.Out)
	return nil
}

func collectDecls(dm *libopenapi.DocumentModel[v3.Document]) ([]*decl, error) {
	c := newCollector()

	for p := dm.Model.Components.Schemas.First(); p != nil; p = p.Next() {
		_, err := c.walk(p.Key(), []string{p.Key()}, p.Value().Schema())
		if err != nil {
			return nil, err
		}
	}

	return c.decls, nil
}

func doGenerate(decls []*decl, importSet set.Set[string], cfg *Config) ([]byte, error) {
	var buf bytes.Buffer
	fmt.Fprintf(&buf, "// Code generated by oapigen; DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "package %s\n\n", packageName(cfg))
	if importSet.Len() > 0 {
		fmt.Fprintf(&buf, "import (\n")
		for module := range importSet {
			fmt.Fprintf(&buf, "%q\n", module)
		}
		fmt.Fprintf(&buf, ")\n\n")
	}

	for _, decl := range decls {
		fmt.Fprintf(&buf, "// %s is the generated type for schema %s\n", decl.name, strings.Join(decl.path, "/"))
		for _, doc := range decl.doc {
			buf.WriteString("// ")
			buf.WriteString(doc)
			buf.WriteString("\n")
		}

		if decl.deprecated {
			buf.WriteString("// Deprecated ")
			buf.WriteString("\n")
		}

		buf.WriteString("type ")
		buf.WriteString(decl.name)
		buf.WriteString(" ")
		writeType(&buf, decl.typ)
		buf.WriteString("\n")

		if len(decl.typ.enum) > 0 {
			buf.WriteString("const (\n")
			for _, enumConst := range decl.typ.enum {
				for _, doc := range enumConst.doc {
					buf.WriteString("// ")
					buf.WriteString(doc)
					buf.WriteString("\n")
				}

				fmt.Fprintf(&buf, "%s %s = %s\n", enumConst.name, decl.name, enumConst.lit)
			}
			buf.WriteString(")\n")
		}

		if decl.typ.kind == kindStruct && decl.typ.elem != nil {
			fmt.Fprintf(&buf, "func (o *%s) UnmarshalJSON(data []byte) error {\n", decl.name)
			fmt.Fprintf(&buf, "type alias %s\n", decl.name)
			buf.WriteString("a := alias{}\n")
			buf.WriteString("if err := json.Unmarshal(data, &a); err != nil {\n")
			buf.WriteString("return err\n")
			buf.WriteString("}\n")
			fmt.Fprintf(&buf, "*o = %s(a)\n", decl.name)
			buf.WriteString("ap := map[string]")
			writeType(&buf, decl.typ.elem)
			buf.WriteString("{}\n")
			buf.WriteString("if err := json.Unmarshal(data, &ap); err != nil {\n")
			buf.WriteString("return err\n")
			buf.WriteString("}\n")
			for _, field := range decl.typ.fields {
				fmt.Fprintf(&buf, "delete(ap, %q)\n", field.jsonName)
			}
			buf.WriteString("if len(ap) > 0 {\n")
			buf.WriteString("o.AdditionalProperties = ap\n")
			buf.WriteString("}\n")
			buf.WriteString("return nil\n")
			buf.WriteString("}\n\n")

			fmt.Fprintf(&buf, "func (o *%s) MarshalJSON() ([]byte, error) {\n", decl.name)
			fmt.Fprintf(&buf, "o := make(map[string]any, len(o.AdditionalProperties)+%d)\n", len(decl.typ.fields))
			for _, field := range decl.typ.fields {
				fmt.Fprintf(&buf, "o[%q] = o.%s\n", field.jsonName, field.name)
			}
			buf.WriteString("for k, v := range o.AdditionalProperties {\n")
			buf.WriteString("o[k] = v\n")
			buf.WriteString("}\n")
			buf.WriteString("return json.Marshal(o)\n")
			buf.WriteString("}\n")
		}
	}

	return buf.Bytes(), nil
}

func writeType(buf *bytes.Buffer, t *goType) {
	switch t.kind {
	case kindInt32:
		buf.WriteString("int32")
	case kindInt64:
		buf.WriteString("int64")
	case kindFloat64:
		buf.WriteString("float64")
	case kindString:
		buf.WriteString("string")
	case kindBool:
		buf.WriteString("bool")
	case kindBytes:
		buf.WriteString("[]byte")
	case kindTime:
		buf.WriteString("time.Time")
	case kindRef:
		buf.WriteString(t.ref)
	case kindSlice:
		buf.WriteString("[]")
		writeType(buf, t.elem)
	case kindMap:
		buf.WriteString("map[string]")
		writeType(buf, t.elem)
	case kindStruct:
		buf.WriteString("struct {\n")
		for _, field := range t.fields {
			for _, doc := range field.doc {
				buf.WriteString("// ")
				buf.WriteString(doc)
				buf.WriteString("\n")
			}

			if field.deprecated {
				buf.WriteString("// Deprecated ")
				buf.WriteString("\n")
			}

			buf.WriteString(field.name)
			buf.WriteString(" ")
			if !field.required {
				buf.WriteString("*")
			}
			writeType(buf, field.typ)
			buf.WriteString(" `json:\"")
			buf.WriteString(field.jsonName)
			if !field.required {
				buf.WriteString(",omitzero")
			}
			buf.WriteString("\"`\n")
		}

		if t.elem != nil {
			buf.WriteString("AdditionalProperties map[string]")
			writeType(buf, t.elem)
			buf.WriteString(" `json:\"-\"`\n")
		}

		buf.WriteString("}")
	case kindJSONRaw:
		buf.WriteString("json.RawMessage")
	}
}

func packageName(cfg *Config) string {
	if cfg.Pkg != "" {
		return cfg.Pkg
	}

	return filepath.Base(filepath.Dir(cfg.Out))
}

func doAnalyzeImports(typ *goType) set.Set[string] {
	importSet := set.NewSet[string]()

	if typ.kind == kindTime {
		importSet.Add("time")
		return importSet
	}

	if typ.kind == kindJSONRaw {
		importSet.Add("encoding/json")
		return importSet
	}

	if typ.kind == kindSlice {
		return doAnalyzeImports(typ.elem)
	}

	if typ.kind == kindMap {
		return doAnalyzeImports(typ.elem)
	}

	if typ.kind == kindStruct {
		if len(typ.fields) > 0 && typ.elem != nil {
			importSet.Add("encoding/json")
		}

		for _, field := range typ.fields {
			importSet.Merge(doAnalyzeImports(field.typ))
		}
	}

	return importSet
}

func analyzeImports(decls []*decl) set.Set[string] {
	importSet := set.NewSet[string]()

	for _, decl := range decls {
		importSet.Merge(doAnalyzeImports(decl.typ))
	}

	return importSet
}
